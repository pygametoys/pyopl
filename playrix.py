#!/usr/bin/env python
# -*- coding: utf8 -*-
#thx to bspal , palxex and Adam Nielsen
#generated by ctopy
import os
import sys
import pyaudio
import pyopl
#**********************************************************

class ADDT:
    def __init__(me):
        me.v = [0x0] * 14

ticksPerSecond = 1000

# Playback frequency.  Try a different value if the output sounds stuttery.
freq = 44100

# How many bytes per sample (2 == 16-bit samples).  This is the only value
# currently implemented.
sample_size = 2

# How many channels to output (2 == stereo).  The OPL2 is mono, so in stereo
# mode the mono samples are copied to both channels.  Enabling OPL3 mode will
# switch the synth to true stereo (and in this case setting num_channels=1
# will just drop the right channel.)  It is done this way so that you can set
# num_channels=2 and output stereo data, and it doesn't matter whether the
# synth is in OPL2 or OPL3 mode - it will always work.
num_channels = 2

# How many samples to synthesise at a time.  Higher values will reduce CPU
# usage but increase lag.
synth_size = 512

# An OPL helper class which handles the delay between notes and buffering
class OPLStream:
    def __init__(self, freq, ticksPerSecond):
        self.opl = pyopl.opl(freq, sampleSize=sample_size, channels=num_channels)
        self.ticksPerSecond = ticksPerSecond
        self.buf = bytearray(synth_size * sample_size * num_channels)
        # self.pyaudio_buf is a different data type but points to the same memory
        # as self.buf, so changing one affects the other.  We put this in the
        # constructor so we don't have to recreate it every time we process
        # samples, which would eat up CPU time unnecessarily.
        self.delay = 0

    def writeReg(self, reg, value):
        self.opl.writeReg(reg, value)

    def wait(self, ticks):
        # Rather than calculating the exact number of samples we need to generate,
        # we just keep generating 512 samples at a time until we've waited as close
        # as possible to the requested delay.
        # This does mean we might wait for up to 511/freq samples too little (at
        # 48kHz that's a worst-case of 10.6ms too short) but nobody should notice
        # and it saves enough CPU time and complexity to be worthwhile.
        self.delay += ticks * freq // self.ticksPerSecond
        while self.delay > synth_size:
            self.opl.getSamples(self.buf)
            # We put the samples into self.buf which also updates self.pyaudio_buf
            stream.write(bytes(self.buf))
            self.delay -= synth_size

        # This is an alternate way of calculating the delay.  It has slightly higher
        # CPU usage but provides more accurate delays (+/- 0.04ms).
        # To use it, rename the function to "wait" and rename the other "wait"
        # function to something else.
    def wait2(self, ticks):
            # Figure out how many samples we need to get to obtain the delay
            fill = ticks * freq // self.ticksPerSecond
            tail = fill % synth_size
            if tail:
                buf_tail = bytearray(tail * sample_size * num_channels)
            # Fill the buffer in 512-sample lots until full
            cur = self.buf
            while fill > 1: # DOSBox synth can't generate < 2 samples
                if fill < synth_size:
                    # Resize the buffer for the last bit
                    cur = buf_tail
                self.opl.getSamples(cur)
                pyaudio_buf = bytes(cur)
                stream.write(pyaudio_buf)
                fill -= synth_size

        
#**********************************************************

#**********************************************************
#      global various and flags                            
#**********************************************************
class RixInfo:
    def __init__(me):
        me.filename = sys.argv[1]
        me.filelen = 0
        me.I = 0
        me.buf_addr = [0] * 32768
        me.buffer = [0] * 300
        me.mus_block = 0
        me.ins_block = 0
        me.adflag = ([0]*3+[1]*3) * 3
        me.reg_data = list(filter(lambda x: 1 - x % 8 // 6, range(22)))
        me.ad_C0_offs = [i % 3 + (i // 6) * 3 for i in range(18)]
        me.modify = [0,3,1,4,2,5,6,9,7,10,8,11,12,15,13,16,14,17,12,15,16,0,14,0,17,0,13,0]
        me.bd_reg_data = [
                                        0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x08,0x04,0x02,0x01,\
                                        0x00,0x01,0x01,0x03,0x0F,0x05,0x00,0x01,0x03,0x0F,0x00,\
                                        0x00,0x00,0x01,0x00,0x00,0x01,0x01,0x0F,0x07,0x00,0x02,\
                                        0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x0A,\
                                        0x04,0x00,0x08,0x0C,0x0B,0x00,0x00,0x00,0x01,0x00,0x00,\
                                        0x00,0x00,0x0D,0x04,0x00,0x06,0x0F,0x00,0x00,0x00,0x00,\
                                        0x01,0x00,0x00,0x0C,0x00,0x0F,0x0B,0x00,0x08,0x05,0x00,\
                                        0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x0F,0x0B,0x00,\
                                        0x07,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,\
                                        0x0F,0x0B,0x00,0x05,0x05,0x00,0x00,0x00,0x00,0x00,0x00,\
                                        0x00,0x01,0x00,0x0F,0x0B,0x00,0x07,0x05,0x00,0x00,0x00,\
                                        0x00,0x00,0x00]
        me.for40reg = [0x7F] * 18
        me.a0b0_data2 = [0] * 11
        me.a0b0_data3 = [0] * 18
        me.a0b0_data4 = [0] * 18
        me.a0b0_data5 = [0] * 96
        me.addrs_head = [0] * 96
        me.rix_stereo = 0
        me.reg_bufs = [ADDT() for _ in range(18)]
        me.mus_time = 0x4268
        me.play_end = 0
        me.music_on = 0
        me.pause_flag = 0
        me.insbuf = [0] * 28
        me.band = 0
        me.band_low = 0
        me.e0_reg_flag = 0
        me.bd_modify = 0
        me.music_spd = 0
        me.displace = [0] * 11
        me.sustain = 0
        me.called=0
#**********************************************************
#      prototype of functions                              
#**********************************************************
def ad_08_reg():    return ad_bop(8,0)

#**********************************************************
#                                                          
#    MAIN FUNCTION OF THE PROGRAM                          
#                                                          
#**********************************************************
def main():
 #-------------------------- Title ------------------------
 #-------------------------- Get file ---------------------
 
 #-------------------------- Usage ------------------------
 
 #------------------------ preparations -------------------
 init()
 set_new_int()
 data_initial()
 prep_int()
 #---------------------------------------------------------
 
#**********************************************************
#                                                          
#               IMPLENEMTS OF FUNCTIONS                    
#                                                          
#**********************************************************
def set_new_int():
    ad_initial()
#----------------------------------------------------------
def Pause():
    g.pause_flag = 1
    for i in range(11):
        switch_ad_bd(i)
#----------------------------------------------------------
def init():
    with open(g.filename, "rb") as f:
        g.buf_addr = bytearray(f.read())
        g.filelen = f.tell()
#----------------------------------------------------------
def data_initial():
    g.music_spd = g.mus_time
    g.rix_stereo = g.buf_addr[2]
    g.mus_block = (g.buf_addr[0x0D]<<8)+g.buf_addr[0x0C]
    g.ins_block = (g.buf_addr[0x09]<<8)+g.buf_addr[0x08]
    g.I = g.mus_block+1
    if g.rix_stereo != 0:
        ad_a0b0_reg(6)
        ad_a0b0_reg(7)
        ad_a0b0_reg(8)
        ad_a0b0l_reg(8,0x18,0)
        ad_a0b0l_reg(7,0x1F,0)
    g.bd_modify = 0
    ad_bd_reg()
    set_speed(g.mus_time)
    g.band = 0
    g.music_on = 1
#----------------------------------------------------------
def set_old_int():
    set_time(0)
#----------------------------------------------------------
def ad_initial():
  for i in range(25):
      res = (i*24+10000)*52088//250000.0*0x24000//0x1B503
      g.buffer[i*12]=(int(res)+4)>>3
      for t in range(12):
          res*=1.06
          g.buffer[i*12+t]=(int(res)+4)>>3
  k=0
  for i in range(8):
      for j in range(12):
          g.a0b0_data5[k] = i
          g.addrs_head[k] = j
          k += 1
  ad_bd_reg()
  ad_08_reg()
  for i in range(9): ad_a0b0_reg(i)
  g.e0_reg_flag = 0x20
  for i in range(18): ad_bop(0xE0+g.reg_data[i],0)
  ad_bop(1,g.e0_reg_flag)
  return
#----------------------------------------------------------
def set_time(v):
    pass
#----------------------------------------------------------
def prep_int():
    set_time(0)
    g.play_end = 0
    while not g.play_end:
        int_08h_entry()
#----------------------------------------------------------
def ad_bop(reg,value):
    #print reg,value
    oplStream.writeReg(reg&0xff,value&0xff)
#------------------------------------------------------
#--------------------------------------------------------------
def int_08h_entry():
    temp = 1
    while temp:
        if g.sustain <= 0:
            temp = rix_proc()
            if temp:
                g.sustain += temp
                oplStream.wait(int(temp))
            else:
                g.play_end = 1
                break
        else:
            if temp:
                g.sustain -= 14
            break
#--------------------------------------------------------------
def rix_proc():
    ctrl = 0
    if g.music_on == 0 or g.pause_flag == 1: return 0
    g.band = 0
    while g.buf_addr[g.I] != 0x80 and g.I<g.filelen-1:
        g.band_low = g.buf_addr[g.I-1]
        ctrl = g.buf_addr[g.I]
        g.I+=2
        if ctrl&0xF0 == 0x90:#set instrument
            rix_get_ins()
            rix_90_pro(ctrl&0x0F)
        elif ctrl&0xF0 == 0xA0:#adjust freq  
            rix_A0_pro(ctrl&0x0F,g.band_low<<6)
        elif ctrl&0xF0 == 0xB0:#adjust volume
            rix_B0_pro(ctrl&0x0F,g.band_low)
        elif ctrl&0xF0 == 0xC0:#set event
            switch_ad_bd(ctrl&0x0F)
            if g.band_low != 0: 
                rix_C0_pro(ctrl&0x0F,g.band_low-1)
        else:
            g.band = (ctrl<<8)+g.band_low
        if g.band != 0:
            return g.band
    music_ctrl()
    set_speed(g.music_spd)
    g.I = g.mus_block+1
    g.band = 0
    g.music_on = 1
    return 0
#--------------------------------------------------------------
def rix_get_ins():
    pos = g.ins_block+(g.band_low<<6)
    for i in range(0,56,2):
        g.insbuf[i//2] = (g.buf_addr[pos+i+1] << 8) + g.buf_addr[pos+i]
#--------------------------------------------------------------
def rix_90_pro(ctrl_l):
    if g.rix_stereo == 0 or ctrl_l < 6:
        ins_to_reg(g.modify[ctrl_l*2],g.insbuf,g.insbuf[26])
        ins_to_reg(g.modify[ctrl_l*2+1],g.insbuf[13:],g.insbuf[27])
        return
    else:
        if ctrl_l > 6:
            ins_to_reg(g.modify[ctrl_l*2+6],g.insbuf,g.insbuf[26])
            return
        else:
            ins_to_reg(12,g.insbuf,g.insbuf[26])
            ins_to_reg(15,g.insbuf[13:],g.insbuf[27])
            return
#--------------------------------------------------------------
def rix_A0_pro(ctrl_l,index):
    if g.rix_stereo == 0 or ctrl_l <= 6:
        prepare_a0b0(ctrl_l,0x3FFF if index>0x3FFF else index)
        ad_a0b0l_reg(ctrl_l,g.a0b0_data3[ctrl_l],g.a0b0_data4[ctrl_l])
    else: return
#--------------------------------------------------------------
def prepare_a0b0(index,v):  # important !
    high = low = 0
    res = (v-0x2000)*0x19
    if res == 0xFF and v>=0x2000: return
    res = float(high|low)//0x2000
    low = int(res)&0xFFFF
    if low < 0:
        low = 0x18-low
        high = 0xFFFF if low<0 else 0
        res = high
        res <<= 16
        res += low
        low = res//0xFFE7
        g.a0b0_data2[index] = low
        low = res
        res = low - 0x18
        high = res%0x19
        low = res // 0x19
        if high != 0:
            low = 0x19
            low = low-high
    else:
        res = high = low
        low = res // 0x19
        g.a0b0_data2[index] = low
        res = high
        low = res%0x19
    low = low*0x18
    g.displace[index] = low
#--------------------------------------------------------------
def ad_a0b0l_reg(index,p2,p3):
    i = p2+g.a0b0_data2[index]
    g.a0b0_data4[index] = p3
    g.a0b0_data3[index] = p2
    i = i if i<=0x5F else 0x5F
    i = i if i>=0 else 0
    data = g.buffer[g.addrs_head[i]+g.displace[index]//2]
    ad_bop(0xA0+index,data)
    data = g.a0b0_data5[i]*4+(0 if p3<1 else 0x20)+((data>>8)&3)
    ad_bop(0xB0+index,data)
#--------------------------------------------------------------
def rix_B0_pro(ctrl_l,index):
    temp = 0
    if g.rix_stereo == 0 or ctrl_l < 6: temp = g.modify[ctrl_l*2+1]
    else:
        temp = ctrl_l*2 if ctrl_l > 6 else ctrl_l*2+1
        temp = g.modify[temp+6]
    g.for40reg[temp] = 0x7F if index>0x7F else index
    ad_40_reg(temp)
#--------------------------------------------------------------
def rix_C0_pro(ctrl_l,index):
    i = index-12 if index>=12 else 0
    if ctrl_l < 6 or g.rix_stereo == 0:
        ad_a0b0l_reg(ctrl_l,i,1)
        return
    else:
        if ctrl_l != 6:
            if ctrl_l == 8:
                ad_a0b0l_reg(ctrl_l,i,0)
                ad_a0b0l_reg(7,i+7,0)
        else: ad_a0b0l_reg(ctrl_l,i,0)
        g.bd_modify |= g.bd_reg_data[ctrl_l]
        ad_bd_reg()
        return
#--------------------------------------------------------------
def switch_ad_bd(index):
    if g.rix_stereo == 0 or index < 6: ad_a0b0l_reg(index,g.a0b0_data3[index],0)
    else:
        g.bd_modify &= (~g.bd_reg_data[index])
        ad_bd_reg()
#--------------------------------------------------------------
def ins_to_reg(index,insb,value):
    for i in range(13): g.reg_bufs[index].v[i] = insb[i]
    g.reg_bufs[index].v[13] = value&3
    ad_bd_reg()
    ad_08_reg()
    ad_40_reg(index)
    ad_C0_reg(index)
    ad_60_reg(index)
    ad_80_reg(index)
    ad_20_reg(index)
    ad_E0_reg(index)
#--------------------------------------------------------------
def ad_E0_reg(index):
    data = 0 if g.e0_reg_flag == 0 else (g.reg_bufs[index].v[13]&3)
    ad_bop(0xE0+g.reg_data[index],data)
#--------------------------------------------------------------
def ad_20_reg(index):
    data = 0 if g.reg_bufs[index].v[9] < 1 else 0x80
    data +=0 if g.reg_bufs[index].v[10] < 1 else 0x40
    data +=0 if g.reg_bufs[index].v[5] < 1 else 0x20
    data +=0 if g.reg_bufs[index].v[11] < 1 else 0x10
    data += (g.reg_bufs[index].v[1]&0x0F)
    ad_bop(0x20+g.reg_data[index],data)
#--------------------------------------------------------------
def ad_80_reg(index):
    data = g.reg_bufs[index].v[7]&0x0F
    temp = g.reg_bufs[index].v[4]
    data |= (temp << 4)
    ad_bop(0x80+g.reg_data[index],data)
#--------------------------------------------------------------
def ad_60_reg(index):
    data = g.reg_bufs[index].v[6]&0x0F
    temp = g.reg_bufs[index].v[3]
    data |= (temp << 4)
    ad_bop(0x60+g.reg_data[index],data)
#--------------------------------------------------------------
def ad_C0_reg(index):
    data = g.reg_bufs[index].v[2]
    if g.adflag[index] == 1: return
    data *= 2
    data |= 1 if g.reg_bufs[index].v[12] < 1 else 0
    ad_bop(0xC0+g.ad_C0_offs[index],data)
#--------------------------------------------------------------
def ad_40_reg(index):
    res = 0
    data = 0
    temp = g.reg_bufs[index].v[0]
    data = 0x3F - (0x3F & g.reg_bufs[index].v[8])
    data *= g.for40reg[index]
    data *= 2
    data += 0x7F
    res = data
    data = res//0xFE
    data -= 0x3F
    data = -data
    data |= temp<<6
    ad_bop(0x40+g.reg_data[index],data)
#--------------------------------------------------------------
def ad_bd_reg():
    data = 0 if g.rix_stereo < 1 else 0x20
    data |= g.bd_modify
    ad_bop(0xBD,data)
#--------------------------------------------------------------
def ad_a0b0_reg(index):
    ad_bop(0xA0+index,0)
    ad_bop(0xB0+index,0)
#--------------------------------------------------------------
def set_speed(spd):
    set_time(spd)
#--------------------------------------------------------------
def music_ctrl():
    g.music_on = 0
    for i in range(11):
        switch_ad_bd(i)
    set_speed(0)

if __name__ == '__main__':
    
    if len(sys.argv) != 2:
        print("Please specify one RIX filename.")
        sys.exit()
    else:
        audio = pyaudio.PyAudio()
        stream = audio.open(
        format = audio.get_format_from_width(sample_size),
        channels = num_channels,
        rate = freq,
        output = True)
        g = RixInfo()
        # Set up the OPL synth
        oplStream = OPLStream(freq, ticksPerSecond)
        # Enable Wavesel on OPL2
        oplStream.writeReg(1, 32)
        main()
        stream.close()
        audio.terminate()
